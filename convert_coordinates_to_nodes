import os
import sys
import pickle
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from matplotlib import patches
from copy import deepcopy
from dataclasses import make_dataclass
import csv
from plot_utils.MM_plot_util import plot 
from plot_utils.MM_maze_util import Maze, NewMaze, PlotMazeNodes

def scale_coordinates_to_maze(maze, raw_x, raw_y):
    """
    Scales raw (x,y) coordinates to fit within the maze's coordinate system.

    Args:
        maze (Maze): The Maze object generated by NewMaze.
        raw_x (np.ndarray): A 1D numpy array of raw x-coordinates.
        raw_y (np.ndarray): A 1D numpy array of raw y-coordinates.

    Returns:
        tuple: A tuple containing two numpy arrays (scaled_x, scaled_y).
    """
    if not isinstance(raw_x, np.ndarray):
        raw_x = np.array(raw_x)
    if not isinstance(raw_y, np.ndarray):
        raw_y = np.array(raw_y)

    # Determine maze plot limits
    min_maze_x = np.min(maze.xc)
    max_maze_x = np.max(maze.xc)
    min_maze_y = np.min(maze.yc)
    max_maze_y = np.max(maze.yc)

    # Determine the range of your raw trajectory data
    raw_x_min = np.min(raw_x)
    raw_x_max = np.max(raw_x)
    raw_y_min = np.min(raw_y)
    raw_y_max = np.max(raw_y)

    # Calculate the scaling factor and offset to map raw data to maze coordinates
    # Add a small epsilon to denominator to prevent division by zero if range is 0
    epsilon = 1e-9

    # Calculate scaling factors to fit trajectory into maze
    # Ensure the scaling maintains aspect ratio if desired, otherwise scale independently
    # For independent scaling as per user's example:
    scale_x = (max_maze_x - min_maze_x) / (raw_x_max - raw_x_min + epsilon)
    scale_y = (max_maze_y - min_maze_y) / (raw_y_max - raw_y_min + epsilon)

    # Calculate offsets to center trajectory in maze
    # This centers the raw data's bounding box within the maze's bounding box after scaling
    offset_x = min_maze_x + (max_maze_x - min_maze_x) / 2 - (raw_x_min + (raw_x_max - raw_x_min) / 2) * scale_x
    offset_y = min_maze_y + (max_maze_y - min_maze_y) / 2 - (raw_y_min + (raw_y_max - raw_y_min) / 2) * scale_y

    # Apply scaling and offset
    scaled_x = raw_x * scale_x + offset_x
    scaled_y = raw_y * scale_y + offset_y

    # Expand trajectory vertical while keeping it centered
    vertical_expansion = 1.1
    traj_center_y = np.mean(scaled_y)
    scaled_y = (scaled_y - traj_center_y) * vertical_expansion + traj_center_y

    horizontal_expansion = 1.05
    traj_center_x = np.mean(scaled_x)
    scaled_x = (scaled_x - traj_center_x) * horizontal_expansion + traj_center_x
    
    return scaled_x, scaled_y

def map_scaled_coords_to_nodes(maze, scaled_x, scaled_y, tolerance=1):
    """
    Maps scaled (x,y) coordinates to the corresponding maze run (node) indices.
    It attempts to snap the scaled coordinates to the nearest valid integer maze cell
    within a given tolerance.

    Args:
        maze (Maze): The Maze object generated by NewMaze.
        scaled_x (np.ndarray): A 1D numpy array of scaled x-coordinates.
        scaled_y (np.ndarray): A 1D numpy array of scaled y-coordinates.
        tolerance (int): The maximum distance (in maze cell units) to search
                         around a scaled point for a valid maze cell.
                         A tolerance of 0 means an exact match is required.

    Returns:
        np.ndarray: A 1D numpy array of run (node) indices.
                    Returns -1 for coordinates that do not map to a valid maze cell
                    within the specified tolerance.
    """
    node_indices = np.full(len(scaled_x), -1, dtype=int)

    for i in range(len(scaled_x)):
        # Round scaled coordinates to the nearest integer to find potential maze cell
        base_maze_x = int(round(scaled_x[i]))
        base_maze_y = int(round(scaled_y[i]))

        found_cell = False
        # Iterate through a square region defined by tolerance
        for dx in range(-tolerance, tolerance + 1):
            for dy in range(-tolerance, tolerance + 1):
                potential_maze_x = base_maze_x + dx
                potential_maze_y = base_maze_y + dy

                # Check if this integer coordinate exists as a valid cell in the maze
                if (potential_maze_x, potential_maze_y) in maze.ce:
                    cell_number = maze.ce[(potential_maze_x, potential_maze_y)]
                    # Use maze.rc to get the run (node) index for this cell
                    node_indices[i] = maze.rc[cell_number]
                    found_cell = True
                    break # Found a cell, no need to check further for this point
            if found_cell:
                break # Found a cell, no need to check further for this point
        # else: If found_cell is still False, the coordinate does not map to a valid maze cell, keep -1

    return node_indices

def get_node_representative_coordinate(maze, node_index):
    """
    Calculates a representative (x,y) coordinate for a given maze run (node).
    This is calculated as the average of all (x,y) coordinates of the cells
    within that run.

    Args:
        maze (Maze): The Maze object generated by NewMaze.
        node_index (int): The index of the run (node) to get the coordinate for.

    Returns:
        tuple: A tuple (avg_x, avg_y) representing the center of the run,
               or None if the node_index is invalid or the run has no cells.
    """
    if not (0 <= node_index < len(maze.ru)):
        print(f"Error: Node index {node_index} is out of bounds.")
        return None

    cells_in_run = maze.ru[node_index]

    if not cells_in_run:
        return None # Run has no cells

    sum_x = 0
    sum_y = 0
    for cell_num in cells_in_run:
        sum_x += maze.xc[cell_num]
        sum_y += maze.yc[cell_num]

    avg_x = sum_x / len(cells_in_run)
    avg_y = sum_y / len(cells_in_run)

    return (avg_x, avg_y)

# Execution
if __name__ == "__main__":
    # 1. Create a maze (e.g., n=6)
    maze_n = 6
    maze = NewMaze(n=maze_n)
    print(f"Maze created with n={maze_n}.")
    print(f"Total cells (nc): {len(maze.xc)}")
    print(f"Total runs (nodes): {len(maze.ru)}")

    # Define the path to CSV file
    csv_file_path = "/Users/camilablank/Downloads/20240509_117o/nose.csv"

    # Read raw coordinates from the CSV file
    try:
        df = pd.read_csv(csv_file_path)
        raw_x_data = df['x'].values
        raw_y_data = df['y'].values
        print(f"\nSuccessfully loaded {len(raw_x_data)} raw coordinates from {csv_file_path}")
        print("First 5 raw coordinates:")
        for i in range(min(5, len(raw_x_data))):
            print(f"  ({raw_x_data[i]}, {raw_y_data[i]})")

    except FileNotFoundError:
        print(f"\nError: CSV file not found at {csv_file_path}. Please check the path.")
    except KeyError as e:
        print(f"\nError: Missing expected column in CSV: {e}. Please ensure 'x' and 'y' columns exist.")
    except Exception as e:
        print(f"\nAn unexpected error occurred while reading the CSV: {e}")


    # Scale the raw coordinates to the maze's coordinate system
    scaled_x_data, scaled_y_data = scale_coordinates_to_maze(maze, raw_x_data, raw_y_data)
    print("\nScaled coordinates (rounded to nearest integer for mapping):")
    for i in range(min(5, len(scaled_x_data))): # Print only first 5 for brevity
        print(f"  ({scaled_x_data[i]:.2f}, {scaled_y_data[i]:.2f}) -> ({int(round(scaled_x_data[i]))}, {int(round(scaled_y_data[i]))})")


    # Map scaled coordinates to run/node indices
    mapped_node_indices = map_scaled_coords_to_nodes(maze, scaled_x_data, scaled_y_data)
    print("\nMapped node indices for scaled coordinates (first 5):")
    for i in range(min(5, len(scaled_x_data))): # Print only first 5 for brevity
        print(f"  Scaled ({scaled_x_data[i]:.2f}, {scaled_y_data[i]:.2f}) maps to Node (Run) Index: {mapped_node_indices[i]}")
        if mapped_node_indices[i] == -1:
            print("    (Note: This point did not map to a valid maze cell.)")

    # Get representative coordinates for specific nodes/runs
    print("\nRepresentative coordinates for some runs (nodes):")
    # Let's check the first few runs and the last run
    num_runs_to_check = min(5, len(maze.ru))
    for node_idx in range(num_runs_to_check):
        rep_coord = get_node_representative_coordinate(maze, node_idx)
        print(f"  Node (Run) {node_idx}: {rep_coord}")


    # Example of getting coordinate for the last run
    if len(maze.ru) > 0:
        last_node_idx = len(maze.ru) - 1
        rep_coord_last = get_node_representative_coordinate(maze, last_node_idx)
        print(f"  Node (Run) {last_node_idx} (last): {rep_coord_last}")

    # Example of an invalid node index
    invalid_node_idx = len(maze.ru) + 10
    rep_coord_invalid = get_node_representative_coordinate(maze, invalid_node_idx)
    print(f"  Node (Run) {invalid_node_idx} (invalid): {rep_coord_invalid}")


    # Save to a new csv file
    output_csv_path = "/Users/camilablank/animal_curiosity_rl/node.csv"

    try:
        output_df = pd.DataFrame({
            'raw_x': raw_x_data,
            'raw_y': raw_y_data,
            'scaled_x': scaled_x_data,
            'scaled_y': scaled_y_data,
            'mapped_node_index': mapped_node_indices
        })
        output_df.to_csv(output_csv_path, index=False)
        print(f"\nProcessed data successfully saved to {output_csv_path}")
    except Exception as e:
        print(f"\nError saving processed data to CSV: {e}")
